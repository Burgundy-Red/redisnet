# 总结
    redis中的网络部分是一个单线程,事件驱动,基于reactor模式实现的网络框架，已经提供了轮询事件处理器的接口。
    需要实现三个事件处理器分别是接受连接和读写socket数据，
    同时设计应用层buffer和应用层协议，协议头部包含了数据长度和类型字段，解决应用层粘包问题。

1. acceptHandler： 接受客户端连接，创建socket句柄，创建client结构（主要包含读写buffer），将socket句柄和读事件注册到eventloop中。
2. readEventHandler: 
    从socket中读取数据，存到rbuffer中，检查是否是一个完整的数据包（头部长度+数据长度>buffer中的数据长度），如果不是完整的就退出，等下一次读。
        如果是一个完整的数据包，则解析数据包中的内容，根据数据头中的type做出不同动作（1.返回一个字符串 2.print内容），如果需要返回的话就构建一个返回数据包
        并写入wbuffer，尝试从wbuffer中写到socket中，如果没有写完则注册写事件到eventloop中，等待可写时继续从wbuffer中读取并写入
3. writeEventHandler:
    检测wbuffer中是否有剩余数据待写，如果没有了就从eventloop中删除写事件。

4. 客户端close，四次握手服务端close

# [粘包问题:](https://zhuanlan.zhihu.com/p/472884146) 
    1. 由于TCP协议本身的机制（面向连接可靠的协议，三次握手四次挥手）客户段与服务端会建立一个链接，数据在链接不断开的情况下，
    可以持续不断地将多个数据包发往服务端，相当于一个流，但是如果发送的网络数据包太小对较小的数据包进行合并（基于此，TCP的
    网络延迟要UDP的高些，因为需要合并延时发送）然后再发送（超时或者包大小足够）。这样的话，服务端在接收到消息（数据流）的
    时候就无法区分哪些数据包是客户端自己分开发送的，这样产生了粘包；
    2. 服务端在接收到数据后，然后放到缓冲区中，如果消息没有被及时从缓存区取走，下次在取数据的时候可能就会出现一次取出多个数据包的情况，造成粘包现象
